// 以下为纯代码版，试着先想想每个printf函数打印了什么
// #include <stdio.h>
// int main()
// {
//     const char *a[] = {"He", "will", "turn into", "first", "in the world!"};
//     const char **b[] = {a + 4, a + 3, a + 2, a + 1, a};
//     const char ***c = b;
//     printf("%s", **(c++ + 4));
//     printf("%s", *--*++c + 2);
//     printf("%s", (*c)[1] + 8);
//     printf("%s", c[-1][1] + 6);
//     return 0;
// }

#include <stdio.h>
int main()
{
    // a是一个数组，每个元素存放字符串常量的地址
    const char *a[] = {"He", "will", "turn into", "first", "in the world!"};
    // b同样是一个数组，每个元素存放字符串常量地址的指针
    const char **b[] = {a + 4, a + 3, a + 2, a + 1, a};
    // c是一根指针，指向存放字符串常量地址指针的数组
    const char ***c = b;

    // c++这个表达式的结果是b数组第1个元素的地址,但实际上c已经指向了b数组的第2个元素
    // c++ + 4 将b数组的第1个元素的地址加4得到b数组的第5个元素的地址
    // *(c++ + 4)解引用得到b数组的第5个元素a
    // **(c++ + 4)将数组名a解引用得到a数组的第1个元素即字符串常量"He"的地址
    printf("%s", **(c++ + 4)); //从首字符'H'开始打印遇到空字符'\0'停止：'H','e','\0'

    // 此时的c指向b数组的第2个元素
    // ++c使c指向b数组的第3个元素
    // * ++c解引用得到b数组的第3个元素即指向a数组的第3个元素的指针
    // -- * ++c使b数组的第3个元素指向a数组的第2个元素
    // *-- * ++c解引用得到a数组的第2个元素即字符串常量"well"的地址
    // *-- * ++c + 2将首字符'w'的地址加2得到第3个字符'l'的地址
    printf("%s", *--*++c + 2); //从字符'l'开始打印遇到空字符'\0'停止：'l','l','\0'

    // 此时的c指向b数组的第3个元素，此时b数组的第3个元素指向的是a数组的第2个元素
    // (*c)得到b数组的第3个元素
    // (*c)[1]将以a数组的第2个元素为首元素向后移动一位直接得到a数组的第3个元素
    // (*c)[1] + 8将首字符't'的地址加8得到第9个字符'o'的地址
    printf("%s", (*c)[1] + 8); //从字符'o'开始打印遇到空字符'\0'停止：'o','\0'

    // 此时的c仍指向b数组的第3个元素
    // c[-1]以b数组的第3个元素为首元素向前移动一位直接得到b数组的第2个元素
    // 而b数组的第2个元素存放的是a数组的第4个元素的地址
    // c[-1][1]以a数组的第4个元素为首元素向后移动一位直接得到a数组的第5个元素
    // c[-1][1] + 6将首字符'i'的地址加6得到第7个字符' '的地址
    printf("%s", c[-1][1] + 6); //从字符' '开始打印遇到空字符'\0'停止：' ','w','o','r','l','d','\0'
    return 0;
}

// 总结：
// 1.字符串常量以字符数组的形式储存在全局区的常量区，
// 以它自身作为数组名，并且每个字符串尾自动加一个'\0'作为字符串结束标志。

// 2.数组名是一个指向首元素的指针常量，只有两种情况例外：
// 其一，sizeof(数组名) 计算的是整个数组的大小，
// 其二，&数组名 得到的是整个数组的地址。

// 3.p[i] 等价于 *(p + i) 等价于 i[p]，原因在于下标本质上是指针运算
// 特别的，当数组作为函数参数传入时 T p[] 等价于 T *p， T为固定大小的数据类型。
